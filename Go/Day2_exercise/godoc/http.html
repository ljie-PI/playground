<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	<!-- PackageName is printed as title by the top-level template -->
		<p><code>import "http"</code></p>
	<p>
The http package implements parsing of HTTP requests, replies,
and URLs and provides an extensible HTTP server and a basic
HTTP client.
</p>

			<p>
			<h4>Package files</h4>
			<span style="font-size:90%">
				<a href="/src/pkg/http/chunked.go">chunked.go</a>
				<a href="/src/pkg/http/client.go">client.go</a>
				<a href="/src/pkg/http/dump.go">dump.go</a>
				<a href="/src/pkg/http/fs.go">fs.go</a>
				<a href="/src/pkg/http/lex.go">lex.go</a>
				<a href="/src/pkg/http/persist.go">persist.go</a>
				<a href="/src/pkg/http/request.go">request.go</a>
				<a href="/src/pkg/http/response.go">response.go</a>
				<a href="/src/pkg/http/server.go">server.go</a>
				<a href="/src/pkg/http/status.go">status.go</a>
				<a href="/src/pkg/http/transfer.go">transfer.go</a>
				<a href="/src/pkg/http/url.go">url.go</a>
			</span>
			</p>
		<h2 id="Constants">Constants</h2>
			<p>
HTTP status codes, defined in RFC 2616.
</p>

			<pre>const (
    StatusContinue           = 100
    StatusSwitchingProtocols = 101

    StatusOK                   = 200
    StatusCreated              = 201
    StatusAccepted             = 202
    StatusNonAuthoritativeInfo = 203
    StatusNoContent            = 204
    StatusResetContent         = 205
    StatusPartialContent       = 206

    StatusMultipleChoices   = 300
    StatusMovedPermanently  = 301
    StatusFound             = 302
    StatusSeeOther          = 303
    StatusNotModified       = 304
    StatusUseProxy          = 305
    StatusTemporaryRedirect = 307

    StatusBadRequest                   = 400
    StatusUnauthorized                 = 401
    StatusPaymentRequired              = 402
    StatusForbidden                    = 403
    StatusNotFound                     = 404
    StatusMethodNotAllowed             = 405
    StatusNotAcceptable                = 406
    StatusProxyAuthRequired            = 407
    StatusRequestTimeout               = 408
    StatusConflict                     = 409
    StatusGone                         = 410
    StatusLengthRequired               = 411
    StatusPreconditionFailed           = 412
    StatusRequestEntityTooLarge        = 413
    StatusRequestURITooLong            = 414
    StatusUnsupportedMediaType         = 415
    StatusRequestedRangeNotSatisfiable = 416
    StatusExpectationFailed            = 417

    StatusInternalServerError     = 500
    StatusNotImplemented          = 501
    StatusBadGateway              = 502
    StatusServiceUnavailable      = 503
    StatusGatewayTimeout          = 504
    StatusHTTPVersionNotSupported = 505
)</pre>
			<p>
TimeFormat is the time format to use with
time.Parse and time.Time.Format when parsing
or generating times in HTTP headers.
It is like time.RFC1123 but hard codes GMT as the time zone.
</p>

			<pre>const TimeFormat = &#34;Mon, 02 Jan 2006 15:04:05 GMT&#34;</pre>
		<h2 id="Variables">Variables</h2>
			
			<pre>var (
    ErrLineTooLong          = &amp;ProtocolError{&#34;header line too long&#34;}
    ErrHeaderTooLong        = &amp;ProtocolError{&#34;header too long&#34;}
    ErrShortBody            = &amp;ProtocolError{&#34;entity body too short&#34;}
    ErrNotSupported         = &amp;ProtocolError{&#34;feature not supported&#34;}
    ErrUnexpectedTrailer    = &amp;ProtocolError{&#34;trailer header without chunked transfer encoding&#34;}
    ErrMissingContentLength = &amp;ProtocolError{&#34;missing ContentLength in HEAD response&#34;}
    ErrNotMultipart         = &amp;ProtocolError{&#34;request Content-Type isn&#39;t multipart/form-data&#34;}
    ErrMissingBoundary      = &amp;ProtocolError{&#34;no multipart boundary param Content-Type&#34;}
)</pre>
			<p>
Errors introduced by the HTTP server.
</p>

			<pre>var (
    ErrWriteAfterFlush = os.NewError(&#34;Conn.Write called after Flush&#34;)
    ErrBodyNotAllowed  = os.NewError(&#34;http: response status code does not allow body&#34;)
    ErrHijacked        = os.NewError(&#34;Conn has been hijacked&#34;)
)</pre>
			<p>
DefaultServeMux is the default ServeMux used by Serve.
</p>

			<pre>var DefaultServeMux = NewServeMux()</pre>
			
			<pre>var ErrPersistEOF = &amp;ProtocolError{&#34;persistent connection closed&#34;}</pre>
			<h2 id="CanonicalHeaderKey">func <a href="/src/pkg/http/request.go?s=10497:10537#L382">CanonicalHeaderKey</a></h2>
			<p><code>func CanonicalHeaderKey(s string) string</code></p>
			<p>
CanonicalHeaderKey returns the canonical format of the
HTTP header key s.  The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase.  For example, the
canonical key for &#34;accept-encoding&#34; is &#34;Accept-Encoding&#34;.
</p>

			<h2 id="DumpRequest">func <a href="/src/pkg/http/dump.go?s=1028:1097#L24">DumpRequest</a></h2>
			<p><code>func DumpRequest(req *Request, body bool) (dump []byte, err os.Error)</code></p>
			<p>
DumpRequest returns the wire representation of req,
optionally including the request body, for debugging.
DumpRequest is semantically a no-op, but in order to
dump the body, it reads the body data into memory and
changes req.Body to refer to the in-memory copy.
</p>

			<h2 id="DumpResponse">func <a href="/src/pkg/http/dump.go?s=1429:1501#L45">DumpResponse</a></h2>
			<p><code>func DumpResponse(resp *Response, body bool) (dump []byte, err os.Error)</code></p>
			<p>
DumpResponse is like DumpRequest but dumps a response.
</p>

			<h2 id="EncodeQuery">func <a href="/src/pkg/http/url.go?s=13522:13568#L480">EncodeQuery</a></h2>
			<p><code>func EncodeQuery(m map[string][]string) string</code></p>
			<p>
EncodeQuery encodes the query represented as a multimap.
</p>

			<h2 id="Error">func <a href="/src/pkg/http/server.go?s=12469:12521#L435">Error</a></h2>
			<p><code>func Error(w ResponseWriter, error string, code int)</code></p>
			<p>
Error replies to the request with the specified error message and HTTP code.
</p>

			<h2 id="EscapeUserinfo">func <a href="/src/pkg/http/url.go?s=6535:6584#L246">EscapeUserinfo</a></h2>
			<p><code>func EscapeUserinfo(user, password string) string</code></p>
			<p>
EscapeUserinfo combines user and password in the form
user:password (or just user if password is empty) and then
escapes it for use as the URL.RawUserinfo field.
</p>
<p>
This functionality should only be used with legacy web sites.
RFC 2396 warns that interpreting Userinfo this way
&ldquo;is NOT RECOMMENDED, because the passing of authentication
information in clear text (such as URI) has proven to be a
security risk in almost every case where it has been used.&rdquo;
</p>

			<h2 id="Handle">func <a href="/src/pkg/http/server.go?s=18749:18793#L642">Handle</a></h2>
			<p><code>func Handle(pattern string, handler Handler)</code></p>
			<p>
Handle registers the handler for the given pattern
in the DefaultServeMux.
</p>

			<h2 id="HandleFunc">func <a href="/src/pkg/http/server.go?s=18934:19005#L646">HandleFunc</a></h2>
			<p><code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code></p>
			<p>
HandleFunc registers the handler function for the given pattern
in the DefaultServeMux.
</p>

			<h2 id="ListenAndServe">func <a href="/src/pkg/http/server.go?s=20244:20302#L699">ListenAndServe</a></h2>
			<p><code>func ListenAndServe(addr string, handler Handler) os.Error</code></p>
			<p>
ListenAndServe listens on the TCP network address addr
and then calls Serve with handler to handle requests
on incoming connections.  Handler is typically nil,
in which case the DefaultServeMux is used.
</p>
<p>
A trivial example server is:
</p>
<pre>package main

import (
	&#34;http&#34;
	&#34;io&#34;
	&#34;log&#34;
)

// hello world, the web server
func HelloServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &#34;hello, world!\n&#34;)
}

func main() {
	http.HandleFunc(&#34;/hello&#34;, HelloServer)
	err := http.ListenAndServe(&#34;:12345&#34;, nil)
	if err != nil {
		log.Exit(&#34;ListenAndServe: &#34;, err.String())
	}
}
</pre>

			<h2 id="ListenAndServeTLS">func <a href="/src/pkg/http/server.go?s=21198:21292#L735">ListenAndServeTLS</a></h2>
			<p><code>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) os.Error</code></p>
			<p>
ListenAndServeTLS acts identically to ListenAndServe, except that it
expects HTTPS connections. Additionally, files containing a certificate and
matching private key for the server must be provided.
</p>
<p>
A trivial example server is:
</p>
<pre>import (
	&#34;http&#34;
	&#34;log&#34;
)

func handler(w http.ResponseWriter, req *http.Request) {
	w.SetHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;)
	w.Write([]byte(&#34;This is an example server.\n&#34;))
}

func main() {
	http.HandleFunc(&#34;/&#34;, handler)
	log.Printf(&#34;About to listen on 10443. Go to <a href="https://127.0.0.1:10443/">https://127.0.0.1:10443/</a>&#34;)
	err := http.ListenAndServeTLS(&#34;:10443&#34;, &#34;cert.pem&#34;, &#34;key.pem&#34;, nil)
	if err != nil {
		log.Exit(err)
	}
}
</pre>
<p>
One can use generate_cert.go in crypto/tls to generate cert.pem and key.pem.
</p>

			<h2 id="NewChunkedWriter">func <a href="/src/pkg/http/chunked.go?s=426:475#L6">NewChunkedWriter</a></h2>
			<p><code>func NewChunkedWriter(w io.Writer) io.WriteCloser</code></p>
			<p>
NewChunkedWriter returns a new writer that translates writes into HTTP
&#34;chunked&#34; format before writing them to w.  Closing the returned writer
sends the final 0-length chunk that marks the end of the stream.
</p>

			<h2 id="NotFound">func <a href="/src/pkg/http/server.go?s=12699:12742#L442">NotFound</a></h2>
			<p><code>func NotFound(w ResponseWriter, r *Request)</code></p>
			<p>
NotFound replies to the request with an HTTP 404 not found error.
</p>

			<h2 id="ParseQuery">func <a href="/src/pkg/http/request.go?s=14914:14981#L590">ParseQuery</a></h2>
			<p><code>func ParseQuery(query string) (m map[string][]string, err os.Error)</code></p>
			<p>
ParseQuery parses the URL-encoded query string and returns
a map listing the values specified for each key.
ParseQuery always returns a non-nil map containing all the
valid query parameters found; err describes the first decoding error
encountered, if any.
</p>

			<h2 id="Redirect">func <a href="/src/pkg/http/server.go?s=13093:13158#L450">Redirect</a></h2>
			<p><code>func Redirect(w ResponseWriter, r *Request, url string, code int)</code></p>
			<p>
Redirect replies to the request with a redirect to url,
which may be a path relative to the request path.
</p>

			<h2 id="Serve">func <a href="/src/pkg/http/server.go?s=19312:19364#L654">Serve</a></h2>
			<p><code>func Serve(l net.Listener, handler Handler) os.Error</code></p>
			<p>
Serve accepts incoming HTTP connections on the listener l,
creating a new service thread for each.  The service threads
read requests and then call handler to reply to them.
Handler is typically nil, in which case the DefaultServeMux is used.
</p>

			<h2 id="ServeFile">func <a href="/src/pkg/http/fs.go?s=4044:4101#L173">ServeFile</a></h2>
			<p><code>func ServeFile(w ResponseWriter, r *Request, name string)</code></p>
			<p>
ServeFile replies to the request with the contents of the named file or directory.
</p>

			<h2 id="StatusText">func <a href="/src/pkg/http/status.go?s=3934:3966#L94">StatusText</a></h2>
			<p><code>func StatusText(code int) string</code></p>
			<p>
StatusText returns a text for the HTTP status code. It returns the empty
string if the code is unknown.
</p>

			<h2 id="URLEscape">func <a href="/src/pkg/http/url.go?s=4539:4570#L176">URLEscape</a></h2>
			<p><code>func URLEscape(s string) string</code></p>
			<p>
URLEscape converts a string into &ldquo;URL encoded&rdquo; form.
Despite the name, this encoding applies only to individual
components of the query portion of the URL.
</p>

			<h2 id="URLUnescape">func <a href="/src/pkg/http/url.go?s=3347:3392#L114">URLUnescape</a></h2>
			<p><code>func URLUnescape(s string) (string, os.Error)</code></p>
			<p>
URLUnescape unescapes a string in &ldquo;URL encoded&rdquo; form,
converting %AB into the byte 0xAB and &#39;+&#39; into &#39; &#39; (space).
It returns an error if any % is not followed
by two hexadecimal digits.
Despite the name, this encoding applies only to individual
components of the query portion of the URL.
</p>

			<h2 id="UnescapeUserinfo">func <a href="/src/pkg/http/url.go?s=5739:5818#L226">UnescapeUserinfo</a></h2>
			<p><code>func UnescapeUserinfo(rawUserinfo string) (user, password string, err os.Error)</code></p>
			<p>
UnescapeUserinfo parses the RawUserinfo field of a URL
as the form user or user:password and unescapes and returns
the two halves.
</p>
<p>
This functionality should only be used with legacy web sites.
RFC 2396 warns that interpreting Userinfo this way
&ldquo;is NOT RECOMMENDED, because the passing of authentication
information in clear text (such as URI) has proven to be a
security risk in almost every case where it has been used.&rdquo;
</p>

			<h2 id="ClientConn">type <a href="/src/pkg/http/persist.go?s=4612:4928#L155">ClientConn</a></h2>
			<p>
A ClientConn sends request and receives headers over an underlying
connection, while respecting the HTTP keepalive logic. ClientConn is not
responsible for closing the underlying connection. One must call Close to
regain control of that connection and deal with it as desired.
</p>

			<p><pre>type ClientConn struct {
    // contains unexported fields
}</pre></p>
				<h3 id="ClientConn.NewClientConn">func <a href="/src/pkg/http/persist.go?s=5056:5115#L167">NewClientConn</a></h3>
				<p><code>func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn</code></p>
				<p>
NewClientConn returns a new ClientConn reading and writing c.  If r is not
nil, it is the buffer to use when reading c.
</p>

				<h3 id="ClientConn.Close">func (*ClientConn) <a href="/src/pkg/http/persist.go?s=5501:5560#L178">Close</a></h3>
				<p><code>func (cc *ClientConn) Close() (c net.Conn, r *bufio.Reader)</code></p>
				<p>
Close detaches the ClientConn and returns the underlying connection as well
as the read-side bufio which may have some left over data. Close may be
called before the user or Read have signaled the end of the keep-alive
logic. The user should not call Close while Read or Write is in progress.
</p>

				<h3 id="ClientConn.Pending">func (*ClientConn) <a href="/src/pkg/http/persist.go?s=6856:6891#L233">Pending</a></h3>
				<p><code>func (cc *ClientConn) Pending() int</code></p>
				<p>
Pending returns the number of unanswered requests
that have been sent on the connection.
</p>

				<h3 id="ClientConn.Read">func (*ClientConn) <a href="/src/pkg/http/persist.go?s=7236:7295#L243">Read</a></h3>
				<p><code>func (cc *ClientConn) Read() (resp *Response, err os.Error)</code></p>
				<p>
Read reads the next response from the wire. A valid response might be
returned together with an ErrPersistEOF, which means that the remote
requested that this be the last request serviced. Read can be called
concurrently with Write, but not with another Read.
</p>

				<h3 id="ClientConn.Write">func (*ClientConn) <a href="/src/pkg/http/persist.go?s=6128:6178#L195">Write</a></h3>
				<p><code>func (cc *ClientConn) Write(req *Request) os.Error</code></p>
				<p>
Write writes a request. An ErrPersistEOF error is returned if the connection
has been closed in an HTTP keepalive sense. If req.Close equals true, the
keepalive connection is logically closed after this request and the opposing
server is informed. An ErrUnexpectedEOF indicates the remote closed the
underlying TCP connection, which is usually considered as graceful close.
Write can be called concurrently with Read, but not with another Write.
</p>

			<h2 id="Handler">type <a href="/src/pkg/http/server.go?s=997:1060#L34">Handler</a></h2>
			<p>
Objects implementing the Handler interface can be
registered to serve a particular path or subtree
in the HTTP server.
</p>
<p>
ServeHTTP should write reply headers and data to the ResponseWriter
and then return.  Returning signals that the request is finished
and that the HTTP server can move on to the next request on
the connection.
</p>

			<p><pre>type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}</pre></p>
				<h3 id="Handler.FileServer">func <a href="/src/pkg/http/fs.go?s=4412:4456#L186">FileServer</a></h3>
				<p><code>func FileServer(root, prefix string) Handler</code></p>
				<p>
FileServer returns a handler that serves HTTP requests
with the contents of the file system rooted at root.
It strips prefix from the incoming requests before
looking up the file name in the file system.
</p>

				<h3 id="Handler.NotFoundHandler">func <a href="/src/pkg/http/server.go?s=12916:12946#L446">NotFoundHandler</a></h3>
				<p><code>func NotFoundHandler() Handler</code></p>
				<p>
NotFoundHandler returns a simple request handler
that replies to each request with a &ldquo;404 page not found&rdquo; reply.
</p>

				<h3 id="Handler.RedirectHandler">func <a href="/src/pkg/http/server.go?s=15296:15346#L523">RedirectHandler</a></h3>
				<p><code>func RedirectHandler(url string, code int) Handler</code></p>
				<p>
RedirectHandler returns a request handler that redirects
each request it receives to the given url using the given
status code.
</p>

			<h2 id="HandlerFunc">type <a href="/src/pkg/http/server.go?s=12215:12262#L425">HandlerFunc</a></h2>
			<p>
The HandlerFunc type is an adapter to allow the use of
ordinary functions as HTTP handlers.  If f is a function
with the appropriate signature, HandlerFunc(f) is a
Handler object that calls f.
</p>

			<p><pre>type HandlerFunc func(ResponseWriter, *Request)</pre></p>
				<h3 id="HandlerFunc.ServeHTTP">func (HandlerFunc) <a href="/src/pkg/http/server.go?s=12294:12354#L428">ServeHTTP</a></h3>
				<p><code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</code></p>
				<p>
ServeHTTP calls f(w, req).
</p>

			<h2 id="ProtocolError">type <a href="/src/pkg/http/request.go?s=675:720#L24">ProtocolError</a></h2>
			<p>
HTTP request parsing errors.
</p>

			<p><pre>type ProtocolError struct {
    os.ErrorString
}</pre></p>
			<h2 id="Request">type <a href="/src/pkg/http/request.go?s=1760:4108#L56">Request</a></h2>
			<p>
A Request represents a parsed HTTP request header.
</p>

			<p><pre>type Request struct {
    Method     string // GET, POST, PUT, etc.
    RawURL     string // The raw URL given in the request.
    URL        *URL   // Parsed URL.
    Proto      string // &#34;HTTP/1.0&#34;
    ProtoMajor int    // 1
    ProtoMinor int    // 0


    // A header maps request lines to their values.
    // If the header says
    //
    //	accept-encoding: gzip, deflate
    //	Accept-Language: en-us
    //	Connection: keep-alive
    //
    // then
    //
    //	Header = map[string]string{
    //		&#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
    //		&#34;Accept-Language&#34;: &#34;en-us&#34;,
    //		&#34;Connection&#34;: &#34;keep-alive&#34;,
    //	}
    //
    // HTTP defines that header names are case-insensitive.
    // The request parser implements this by canonicalizing the
    // name, making the first character and any characters
    // following a hyphen uppercase and the rest lowercase.
    Header map[string]string

    // The message body.
    Body io.ReadCloser

    // ContentLength records the length of the associated content.
    // The value -1 indicates that the length is unknown.
    // Values &gt;= 0 indicate that the given number of bytes may be read from Body.
    ContentLength int64

    // TransferEncoding lists the transfer encodings from outermost to innermost.
    // An empty list denotes the &#34;identity&#34; encoding.
    TransferEncoding []string

    // Whether to close the connection after replying to this request.
    Close bool

    // The host on which the URL is sought.
    // Per RFC 2616, this is either the value of the Host: header
    // or the host name given in the URL itself.
    Host string

    // The referring URL, if sent in the request.
    //
    // Referer is misspelled as in the request itself,
    // a mistake from the earliest days of HTTP.
    // This value can also be fetched from the Header map
    // as Header[&#34;Referer&#34;]; the benefit of making it
    // available as a structure field is that the compiler
    // can diagnose programs that use the alternate
    // (correct English) spelling req.Referrer but cannot
    // diagnose programs that use Header[&#34;Referrer&#34;].
    Referer string

    // The User-Agent: header string, if sent in the request.
    UserAgent string

    // The parsed form. Only available after ParseForm is called.
    Form map[string][]string

    // Trailer maps trailer keys to values.  Like for Header, if the
    // response has multiple trailer lines with the same key, they will be
    // concatenated, delimited by commas.
    Trailer map[string]string
}</pre></p>
				<h3 id="Request.ReadRequest">func <a href="/src/pkg/http/request.go?s=12274:12336#L478">ReadRequest</a></h3>
				<p><code>func ReadRequest(b *bufio.Reader) (req *Request, err os.Error)</code></p>
				<p>
ReadRequest reads and parses a request from b.
</p>

				<h3 id="Request.FormValue">func (*Request) <a href="/src/pkg/http/request.go?s=16498:16544#L659">FormValue</a></h3>
				<p><code>func (r *Request) FormValue(key string) string</code></p>
				<p>
FormValue returns the first value for the named component of the query.
FormValue calls ParseForm if necessary.
</p>

				<h3 id="Request.MultipartReader">func (*Request) <a href="/src/pkg/http/request.go?s=4480:4544#L138">MultipartReader</a></h3>
				<p><code>func (r *Request) MultipartReader() (multipart.Reader, os.Error)</code></p>
				<p>
MultipartReader returns a MIME multipart reader if this is a
multipart/form-data POST request, else returns nil and an error.
</p>

				<h3 id="Request.ParseForm">func (*Request) <a href="/src/pkg/http/request.go?s=15655:15699#L622">ParseForm</a></h3>
				<p><code>func (r *Request) ParseForm() (err os.Error)</code></p>
				<p>
ParseForm parses the request body as a form for POST requests, or the raw query for GET requests.
It is idempotent.
</p>

				<h3 id="Request.ProtoAtLeast">func (*Request) <a href="/src/pkg/http/request.go?s=4208:4261#L131">ProtoAtLeast</a></h3>
				<p><code>func (r *Request) ProtoAtLeast(major, minor int) bool</code></p>
				<p>
ProtoAtLeast returns whether the HTTP protocol used
in the request is at least major.minor.
</p>

				<h3 id="Request.Write">func (*Request) <a href="/src/pkg/http/request.go?s=5456:5503#L176">Write</a></h3>
				<p><code>func (req *Request) Write(w io.Writer) os.Error</code></p>
				<p>
Write writes an HTTP/1.1 request -- header and body -- in wire format.
This method consults the following fields of req:
</p>
<pre>Host
RawURL, if non-empty, or else URL
Method (defaults to &#34;GET&#34;)
UserAgent (defaults to defaultUserAgent)
Referer
Header
Body
</pre>
<p>
If Body is present, Write forces &#34;Transfer-Encoding: chunked&#34; as a header
and then closes Body when finished sending it.
</p>

			<h2 id="Response">type <a href="/src/pkg/http/response.go?s=472:2217#L17">Response</a></h2>
			<p>
Response represents the response from an HTTP request.
</p>

			<p><pre>type Response struct {
    Status     string // e.g. &#34;200 OK&#34;
    StatusCode int    // e.g. 200
    Proto      string // e.g. &#34;HTTP/1.0&#34;
    ProtoMajor int    // e.g. 1
    ProtoMinor int    // e.g. 0


    // RequestMethod records the method used in the HTTP request.
    // Header fields such as Content-Length have method-specific meaning.
    RequestMethod string // e.g. &#34;HEAD&#34;, &#34;CONNECT&#34;, &#34;GET&#34;, etc.


    // Header maps header keys to values.  If the response had multiple
    // headers with the same key, they will be concatenated, with comma
    // delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers
    // be semantically equivalent to a comma-delimited sequence.) Values
    // duplicated by other fields in this struct (e.g., ContentLength) are
    // omitted from Header.
    //
    // Keys in the map are canonicalized (see CanonicalHeaderKey).
    Header map[string]string

    // Body represents the response body.
    Body io.ReadCloser

    // ContentLength records the length of the associated content.  The
    // value -1 indicates that the length is unknown.  Unless RequestMethod
    // is &#34;HEAD&#34;, values &gt;= 0 indicate that the given number of bytes may
    // be read from Body.
    ContentLength int64

    // Contains transfer encodings from outer-most to inner-most. Value is
    // nil, means that &#34;identity&#34; encoding is used.
    TransferEncoding []string

    // Close records whether the header directed that the connection be
    // closed after reading Body.  The value is advice for clients: neither
    // ReadResponse nor Response.Write ever closes a connection.
    Close bool

    // Trailer maps trailer keys to values.  Like for Header, if the
    // response has multiple trailer lines with the same key, they will be
    // concatenated, delimited by commas.
    Trailer map[string]string
}</pre></p>
				<h3 id="Response.Get">func <a href="/src/pkg/http/client.go?s=3075:3140#L109">Get</a></h3>
				<p><code>func Get(url string) (r *Response, finalURL string, err os.Error)</code></p>
				<p>
Get issues a GET to the specified URL.  If the response is one of the following
redirect codes, it follows the redirect, up to a maximum of 10 redirects:
</p>
<pre>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</pre>
<p>
finalURL is the URL from which the response was fetched -- identical to the
input URL unless redirects were followed.
</p>
<p>
Caller should close r.Body when done reading it.
</p>

				<h3 id="Response.Head">func <a href="/src/pkg/http/client.go?s=5382:5431#L202">Head</a></h3>
				<p><code>func Head(url string) (r *Response, err os.Error)</code></p>
				<p>
Head issues a HEAD to the specified URL.
</p>

				<h3 id="Response.Post">func <a href="/src/pkg/http/client.go?s=3998:4080#L146">Post</a></h3>
				<p><code>func Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error)</code></p>
				<p>
Post issues a POST to the specified URL.
</p>
<p>
Caller should close r.Body when done reading it.
</p>

				<h3 id="Response.PostForm">func <a href="/src/pkg/http/client.go?s=4574:4651#L170">PostForm</a></h3>
				<p><code>func PostForm(url string, data map[string]string) (r *Response, err os.Error)</code></p>
				<p>
PostForm issues a POST to the specified URL,
with data&#39;s keys and values urlencoded as the request body.
</p>
<p>
Caller should close r.Body when done reading it.
</p>

				<h3 id="Response.ReadResponse">func <a href="/src/pkg/http/response.go?s=2574:2661#L67">ReadResponse</a></h3>
				<p><code>func ReadResponse(r *bufio.Reader, requestMethod string) (resp *Response, err os.Error)</code></p>
				<p>
ReadResponse reads and returns an HTTP response from r.  The RequestMethod
parameter specifies the method used in the corresponding request (e.g.,
&#34;GET&#34;, &#34;HEAD&#34;).  Clients must call resp.Body.Close when finished reading
resp.Body.  After that call, clients can inspect resp.Trailer to find
key/value pairs included in the response trailer.
</p>

				<h3 id="Response.AddHeader">func (*Response) <a href="/src/pkg/http/response.go?s=4204:4251#L138">AddHeader</a></h3>
				<p><code>func (r *Response) AddHeader(key, value string)</code></p>
				<p>
AddHeader adds a value under the given key.  Keys are not case sensitive.
</p>

				<h3 id="Response.GetHeader">func (*Response) <a href="/src/pkg/http/response.go?s=4741:4796#L153">GetHeader</a></h3>
				<p><code>func (r *Response) GetHeader(key string) (value string)</code></p>
				<p>
GetHeader returns the value of the response header with the given key.
If there were multiple headers with this key, their values are concatenated,
with a comma delimiter.  If there were no response headers with the given
key, GetHeader returns an empty string.  Keys are not case sensitive.
</p>

				<h3 id="Response.ProtoAtLeast">func (*Response) <a href="/src/pkg/http/response.go?s=4943:4997#L159">ProtoAtLeast</a></h3>
				<p><code>func (r *Response) ProtoAtLeast(major, minor int) bool</code></p>
				<p>
ProtoAtLeast returns whether the HTTP protocol used
in the response is at least major.minor.
</p>

				<h3 id="Response.Write">func (*Response) <a href="/src/pkg/http/response.go?s=5408:5457#L177">Write</a></h3>
				<p><code>func (resp *Response) Write(w io.Writer) os.Error</code></p>
				<p>
Writes the response (header, body and trailer) in wire format. This method
consults the following fields of resp:
</p>
<pre>StatusCode
ProtoMajor
ProtoMinor
RequestMethod
TransferEncoding
Trailer
Body
ContentLength
Header, values for non-canonical keys will have unpredictable behavior
</pre>

			<h2 id="ResponseWriter">type <a href="/src/pkg/http/server.go?s=1153:2687#L40">ResponseWriter</a></h2>
			<p>
A ResponseWriter interface is used by an HTTP handler to
construct an HTTP response.
</p>

			<p><pre>type ResponseWriter interface {
    // RemoteAddr returns the address of the client that sent the current request
    RemoteAddr() string

    // UsingTLS returns true if the client is connected using TLS
    UsingTLS() bool

    // SetHeader sets a header line in the eventual response.
    // For example, SetHeader(&#34;Content-Type&#34;, &#34;text/html; charset=utf-8&#34;)
    // will result in the header line
    //
    //	Content-Type: text/html; charset=utf-8
    //
    // being sent.  UTF-8 encoded HTML is the default setting for
    // Content-Type in this library, so users need not make that
    // particular call.  Calls to SetHeader after WriteHeader (or Write)
    // are ignored.
    SetHeader(string, string)

    // Write writes the data to the connection as part of an HTTP reply.
    // If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)
    // before writing the data.
    Write([]byte) (int, os.Error)

    // WriteHeader sends an HTTP response header with status code.
    // If WriteHeader is not called explicitly, the first call to Write
    // will trigger an implicit WriteHeader(http.StatusOK).
    // Thus explicit calls to WriteHeader are mainly used to
    // send error codes.
    WriteHeader(int)

    // Flush sends any buffered data to the client.
    Flush()

    // Hijack lets the caller take over the connection.
    // After a call to Hijack(), the HTTP server library
    // will not do anything else with the connection.
    // It becomes the caller&#39;s responsibility to manage
    // and close the connection.
    Hijack() (io.ReadWriteCloser, *bufio.ReadWriter, os.Error)
}</pre></p>
			<h2 id="ServeMux">type <a href="/src/pkg/http/server.go?s=16506:16552#L551">ServeMux</a></h2>
			<p>
ServeMux is an HTTP request multiplexer.
It matches the URL of each incoming request against a list of registered
patterns and calls the handler for the pattern that
most closely matches the URL.
</p>
<p>
Patterns named fixed paths, like &#34;/favicon.ico&#34;,
or subtrees, like &#34;/images/&#34; (note the trailing slash).
Patterns must begin with /.
Longer patterns take precedence over shorter ones, so that
if there are handlers registered for both &#34;/images/&#34;
and &#34;/images/thumbnails/&#34;, the latter handler will be
called for paths beginning &#34;/images/thumbnails/&#34; and the
former will receiver requests for any other paths in the
&#34;/images/&#34; subtree.
</p>
<p>
In the future, the pattern syntax may be relaxed to allow
an optional host-name at the beginning of the pattern,
so that a handler might register for the two patterns
&#34;/codesearch&#34; and &#34;codesearch.google.com/&#34;
without taking over requests for <a href="http://www.google.com/">http://www.google.com/</a>.
</p>
<p>
ServeMux also takes care of sanitizing the URL request path,
redirecting any request containing . or .. elements to an
equivalent .- and ..-free URL.
</p>

			<p><pre>type ServeMux struct {
    // contains unexported fields
}</pre></p>
				<h3 id="ServeMux.NewServeMux">func <a href="/src/pkg/http/server.go?s=16607:16635#L556">NewServeMux</a></h3>
				<p><code>func NewServeMux() *ServeMux</code></p>
				<p>
NewServeMux allocates and returns a new ServeMux.
</p>

				<h3 id="ServeMux.Handle">func (*ServeMux) <a href="/src/pkg/http/server.go?s=18065:18125#L620">Handle</a></h3>
				<p><code>func (mux *ServeMux) Handle(pattern string, handler Handler)</code></p>
				<p>
Handle registers the handler for the given pattern.
</p>

				<h3 id="ServeMux.HandleFunc">func (*ServeMux) <a href="/src/pkg/http/server.go?s=18532:18619#L636">HandleFunc</a></h3>
				<p><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code></p>
				<p>
HandleFunc registers the handler function for the given pattern.
</p>

				<h3 id="ServeMux.ServeHTTP">func (*ServeMux) <a href="/src/pkg/http/server.go?s=17500:17560#L593">ServeHTTP</a></h3>
				<p><code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</code></p>
				<p>
ServeHTTP dispatches the request to the handler whose
pattern most closely matches the request URL.
</p>

			<h2 id="ServerConn">type <a href="/src/pkg/http/persist.go?s=713:1012#L14">ServerConn</a></h2>
			<p>
A ServerConn reads requests and sends responses over an underlying
connection, until the HTTP keepalive logic commands an end. ServerConn
does not close the underlying connection. Instead, the user calls Close
and regains control over the connection. ServerConn supports pipe-lining,
i.e. requests can be read out of sync (but in the same order) while the
respective responses are sent.
</p>

			<p><pre>type ServerConn struct {
    // contains unexported fields
}</pre></p>
				<h3 id="ServerConn.NewServerConn">func <a href="/src/pkg/http/persist.go?s=1140:1199#L26">NewServerConn</a></h3>
				<p><code>func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn</code></p>
				<p>
NewServerConn returns a new ServerConn reading and writing c.  If r is not
nil, it is the buffer to use when reading c.
</p>

				<h3 id="ServerConn.Close">func (*ServerConn) <a href="/src/pkg/http/persist.go?s=1572:1631#L37">Close</a></h3>
				<p><code>func (sc *ServerConn) Close() (c net.Conn, r *bufio.Reader)</code></p>
				<p>
Close detaches the ServerConn and returns the underlying connection as well
as the read-side bufio which may have some left over data. Close may be
called before Read has signaled the end of the keep-alive logic. The user
should not call Close while Read or Write is in progress.
</p>

				<h3 id="ServerConn.Pending">func (*ServerConn) <a href="/src/pkg/http/persist.go?s=3318:3353#L108">Pending</a></h3>
				<p><code>func (sc *ServerConn) Pending() int</code></p>
				<p>
Pending returns the number of unanswered requests
that have been received on the connection.
</p>

				<h3 id="ServerConn.Read">func (*ServerConn) <a href="/src/pkg/http/persist.go?s=2058:2115#L52">Read</a></h3>
				<p><code>func (sc *ServerConn) Read() (req *Request, err os.Error)</code></p>
				<p>
Read returns the next request on the wire. An ErrPersistEOF is returned if
it is gracefully determined that there are no more requests (e.g. after the
first request on an HTTP/1.0 connection, or after a Connection:close on a
HTTP/1.1 connection). Read can be called concurrently with Write, but not
with another Read.
</p>

				<h3 id="ServerConn.Write">func (*ServerConn) <a href="/src/pkg/http/persist.go?s=3727:3779#L118">Write</a></h3>
				<p><code>func (sc *ServerConn) Write(resp *Response) os.Error</code></p>
				<p>
Write writes a repsonse. To close the connection gracefully, set the
Response.Close field to true. Write should be considered operational until
it returns an error, regardless of any errors returned on the Read side.
Write can be called concurrently with Read, but not with another Write.
</p>

			<h2 id="URL">type <a href="/src/pkg/http/url.go?s=7254:7665#L264">URL</a></h2>
			<p>
A URL represents a parsed URL (technically, a URI reference).
The general form represented is:
</p>
<pre>scheme://[userinfo@]host/path[?query][#fragment]
</pre>
<p>
The Raw, RawAuthority, RawPath, and RawQuery fields are in &#34;wire format&#34;
(special characters must be hex-escaped if not meant to have special meaning).
All other fields are logical values; &#39;+&#39; or &#39;%&#39; represent themselves.
</p>
<p>
The various Raw values are supplied in wire format because
clients typically have to split them into pieces before further
decoding.
</p>

			<p><pre>type URL struct {
    Raw          string // the original string
    Scheme       string // scheme
    RawAuthority string // [userinfo@]host
    RawUserinfo  string // userinfo
    Host         string // host
    RawPath      string // /path[?query][#fragment]
    Path         string // /path
    OpaquePath   bool   // path is opaque (unrooted when scheme is present)
    RawQuery     string // query
    Fragment     string // fragment
}</pre></p>
				<h3 id="URL.ParseRequestURL">func <a href="/src/pkg/http/url.go?s=9376:9436#L332">ParseRequestURL</a></h3>
				<p><code>func ParseRequestURL(rawurl string) (url *URL, err os.Error)</code></p>
				<p>
ParseRequestURL parses rawurl into a URL structure.  It assumes that
rawurl was received from an HTTP request, so the rawurl is interpreted
only as an absolute URI or an absolute path.
The string rawurl is assumed not to have a #fragment suffix.
(Web browsers strip #fragment before sending the URL to a web server.)
</p>

				<h3 id="URL.ParseURL">func <a href="/src/pkg/http/url.go?s=8953:9006#L323">ParseURL</a></h3>
				<p><code>func ParseURL(rawurl string) (url *URL, err os.Error)</code></p>
				<p>
ParseURL parses rawurl into a URL structure.
The string rawurl is assumed not to have a #fragment suffix.
(Web browsers strip #fragment before sending the URL to a web server.)
The rawurl may be relative or absolute.
</p>

				<h3 id="URL.ParseURLReference">func <a href="/src/pkg/http/url.go?s=12031:12096#L421">ParseURLReference</a></h3>
				<p><code>func ParseURLReference(rawurlref string) (url *URL, err os.Error)</code></p>
				<p>
ParseURLReference is like ParseURL but allows a trailing #fragment.
</p>

				<h3 id="URL.IsAbs">func (*URL) <a href="/src/pkg/http/url.go?s=14540:14568#L522">IsAbs</a></h3>
				<p><code>func (url *URL) IsAbs() bool</code></p>
				<p>
IsAbs returns true if the URL is absolute.
</p>

				<h3 id="URL.ParseURL">func (*URL) <a href="/src/pkg/http/url.go?s=14810:14864#L529">ParseURL</a></h3>
				<p><code>func (base *URL) ParseURL(ref string) (*URL, os.Error)</code></p>
				<p>
ParseURL parses a URL in the context of a base URL.  The URL in ref
may be relative or absolute.  ParseURL returns nil, err on parse
failure, otherwise its return value is the same as ResolveReference.
</p>

				<h3 id="URL.ResolveReference">func (*URL) <a href="/src/pkg/http/url.go?s=15374:15422#L543">ResolveReference</a></h3>
				<p><code>func (base *URL) ResolveReference(ref *URL) *URL</code></p>
				<p>
ResolveReference resolves a URI reference to an absolute URI from
an absolute base URI, per RFC 2396 Section 5.2.  The URI reference
may be relative or absolute.  ResolveReference always returns a new
URL instance, even if the returned URL is identical to either the
base or reference. If ref is an absolute URL, then ResolveReference
ignores base and returns a copy of ref.
</p>

				<h3 id="URL.String">func (*URL) <a href="/src/pkg/http/url.go?s=12692:12723#L443">String</a></h3>
				<p><code>func (url *URL) String() string</code></p>
				<p>
String reassembles url into a valid URL string.
</p>
<p>
There are redundant fields stored in the URL structure:
the String method consults Scheme, Path, Host, RawUserinfo,
RawQuery, and Fragment, but not Raw, RawPath or Authority.
</p>

			<h2 id="URLError">type <a href="/src/pkg/http/url.go?s=361:429#L7">URLError</a></h2>
			<p>
URLError reports an error and the operation and URL that caused it.
</p>

			<p><pre>type URLError struct {
    Op    string
    URL   string
    Error os.Error
}</pre></p>
				<h3 id="URLError.String">func (*URLError) <a href="/src/pkg/http/url.go?s=431:465#L13">String</a></h3>
				<p><code>func (e *URLError) String() string</code></p>
				
			<h2 id="URLEscapeError">type <a href="/src/pkg/http/url.go?s=1037:1063#L50">URLEscapeError</a></h2>
			
			<p><pre>type URLEscapeError string</pre></p>
				<h3 id="URLEscapeError.String">func (URLEscapeError) <a href="/src/pkg/http/url.go?s=1065:1104#L52">String</a></h3>
				<p><code>func (e URLEscapeError) String() string</code></p>
				
	<h2>Other packages</h2>
	<p>
	<a href="?p=main">main</a><br />
	</p>
	<h2 id="Subdirectories">Subdirectories</h2>
	<p>
	<table class="layout">
	<tr>
	<th align="left" colspan="1">Name</th>
	<td width="25">&nbsp;</td>
	<th align="left">Synopsis</th>
	</tr>
	<tr>
	<th align="left"><a href="..">..</a></th>
	</tr>
		<tr>
		
		<td align="left" colspan="1"><a href="pprof">pprof</a></td>
		<td></td>
		<td align="left"></td>
		</tr>
		<tr>
		
		<td align="left" colspan="1"><a href="testdata">testdata</a></td>
		<td></td>
		<td align="left"></td>
		</tr>
	</table>
	</p>
